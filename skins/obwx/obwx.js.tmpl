// Makeshift debug function
function debug ( msg ) {
        console.log( "Info: " + msg );
    }

// Connect to mqtt server
function connect() {
    client = new Paho.Client("$Extras.websocket_host", $Extras.websocket_port, mqttclient);

    let mqtt_options = {
        useSSL: true,
        reconnect: true,
        onSuccess: onConnect,
        onFailure: onFailure
    }
    client.onConnectionLost = onConnectionLost;
    client.onMessageArrived = onMessageArrived;
    client.connect( mqtt_options );
}

function onConnect () {
    client.subscribe( "$Extras.websocket_topic" );
    debug("Successfully connected to mqtt server");
}

function onFailure () {
    debug("Connection to mqtt server FAILED");
}

function onConnectionLost ( responseObject ) {
    if ( responseObject.errorCode !== 0 ) {
        debug("MQTT disconnected: " + responseObject.errorMessage);
    }
}

// Process incoming mqtt data
function onMessageArrived ( message ) {
    process_payload ( message.payloadString  );
}

function process_payload ( data ) {
    data = jQuery.parseJSON ( data );

    // interval_minute is unique to mqtt archive updates, signaling forecast.json has been updated
    if ( data.hasOwnProperty( 'interval_minute' ) ) {
        // Get and process forecast after 15 sec delay to allow new json files to be fully updated by weewx
        setTimeout( function() {
            get_forecast();
        }, 15000);
    }

    // Update webpage with the live data
    jQuery(".websocket-status").html( dayjs().format("MMM D, hh:mm:ss A") );

    if ( data.hasOwnProperty( 'barometer_inHg' ) ) {
        jQuery(".barometer").html("Barometer: " + parseFloat( data.barometer_inHg ).toFixed(2) );
    }

    if ( data.hasOwnProperty( 'dewpoint_F' ) ) {
        jQuery(".dewpoint").html("Dewpoint: " +  parseFloat( data.dewpoint_F ).toFixed(1) + "&deg;" );
    }

    if ( data.hasOwnProperty( 'extraHumid1' ) ) {
        jQuery(".extraHumid1").html("extraHumid1: " +  parseFloat( data.extraHumid1 ).toFixed(0) );
    }

    if ( data.hasOwnProperty( 'extraHumid2' ) ) {
        jQuery(".extraHumid2").html("extraHumid2: " +  parseFloat( data.extraHumid2 ).toFixed(0) );
    }

    if ( data.hasOwnProperty( 'extraTemp1_F' ) ) {
        jQuery(".extraTemp1").html("Inside Temp 1: " +  parseFloat( data.extraTemp1_F ).toFixed(1) );
    }

    if ( data.hasOwnProperty( 'extraTemp2_F' ) ) {
        jQuery(".extraTemp2").html("Inside Temp 2: " +  parseFloat( data.extraTemp2_F ).toFixed(1) );
    }

    if ( data.hasOwnProperty( 'inDewpoint_F' ) ) {
        jQuery(".inDewpoint").html("inDewpoint: " +  parseFloat( data.inDewpoint_F ).toFixed(1) );
    }

    if ( data.hasOwnProperty( 'inHumidity' ) ) {
        jQuery(".inHumidity").html("Raspi Humidity: " +  parseFloat( data.inHumidity ).toFixed(0) );
    }

    if ( data.hasOwnProperty( 'inTemp_F' ) ) {
        jQuery(".inTemp").html("Raspi Temp: " +  parseFloat( data.inTemp_F ).toFixed(1) );
    }

    if ( data.hasOwnProperty( 'outHumidity' ) ) {
        jQuery(".outHumidity").html( "Humidity: " + parseFloat( data.outHumidity ).toFixed(1) + "&percnt;");
    }

    if ( data.hasOwnProperty( 'outTemp_F' ) ) {
        jQuery(".outTemp").html( parseFloat( data.outTemp_F ).toFixed(1) );
    }
}

// Fetch the data from forecast.json
function get_forecast () {
    jQuery.getJSON ( "forecast.json", process_forecast );
}

// Update page with new json data
function process_forecast ( data ) {

    // Current Wx Icon
    let icon = data.current[0].response[0].periods[0].icon;
    icon = icon.split(".");
    jQuery(".current-wx-icon").html('<img src="./icons/' + icon[0] + '@2x.png">');
    jQuery(".current-wx-text").html( data.current[0].response[0].periods[0].weatherPrimary );

    // Alerts
    if ( data.alerts[0].success && data.alerts[0].error === null ) {

        let wx_alert_html = "";
        // Build alerts HTML
        for ( let i = 0; i < data.alerts[0].response.length; i++ ) {
            
            let wx_alert = data.alerts[0].response[i].details.name;
            let wx_alert_start = dayjs(new Date( data.alerts[0].response[i].timestamps.beginsISO )).format('ddd h:mm A');
            let wx_alert_end = dayjs(new Date( data.alerts[0].response[i].timestamps.expiresISO )).format('ddd h:mm A');

            wx_alert_html += '<div class="wx-alert-' + i + '">' + wx_alert + " in effect " + wx_alert_start + ' until ' + wx_alert_end + '</div>';
        }

        jQuery(".weather-alerts").html( wx_alert_html );
    }

    // More updates
    // jQuery(".KMEM-wind-direction-deg").html( data.current[0].response[0].ob.windDirDEG + " &deg;");
    // jQuery(".KMEM-wind-speed-mph").html( data.current[0].response[0].ob.windSpeedMPH + " mph" );

    // Loop through METAR data for each station
    for ( let i = 0; i < data.observations[0].response.length; i++ ) {

        // Display station ID and update times, color code depending on age of the data 
        function metarColorCode ( loc , time ) {

            // Display time of observations
            jQuery("." + loc + "-id-updated").html( "<div class='metar-id'>" + loc + "</div><div class='metar-update-time'>" + dayjs.unix(time).format("h:mm A") + "</div>" ); 

            // Color code station ID based on age of observation
            let timeDiff = dayjs().unix() - dayjs(time);
            if ( timeDiff < 1200 ) {
                // Fresh data, less than 20 minutes old
                jQuery("." + loc + "-id-updated").css( "color", "rgb(90, 170, 90)" );
            } else if ( timeDiff > 1200 && timeDiff < 2400 ) {
                // Semistale data - between 20 and 40 minutes old 
                jQuery("." + loc + "-id-updated").css( "color", "rgb(244, 198, 113)" );
            } else if ( timeDiff > 2400 && timeDiff < 3600 ) {
                // Stale data - between 40 and 60 minutes old
                jQuery("." + loc + "-id-updated").css( "color", "rgb(220, 120, 120)" );
            } else {
                // Old data - older than an hour
                jQuery("." + loc + "-id-updated").css( "color", "rgb(160, 90, 90)" );
            }
        }

        // Rotate wind direction widgit arrow
        function rotateWindDir ( loc , k_newRotation ) {
            if ( k_newRotation == "N/A") { return; }
            
            let k_currentRotation;
            let k_finalRotation;
            
            k_finalRotation = k_finalRotation || 0; // if k_finalRotation undefined or 0, make 0, else k_finalRotation
            k_currentRotation = k_finalRotation % 360;
            
            if ( k_currentRotation < 0 ) { k_currentRotation += 360; }
            if ( k_currentRotation < 180 && (k_newRotation > (k_currentRotation + 180)) ) { k_finalRotation -= 360; }
            if ( k_currentRotation >= 180 && (k_newRotation <= (k_currentRotation - 180)) ) { k_finalRotation += 360; }
            
            k_finalRotation += (k_newRotation - k_currentRotation);
            
            jQuery("." + loc + "-windDirectionArrow").css( "transform", "rotate(" + k_finalRotation + "deg)" );
        }

        // Rotate wind speed widget arrow
        function rotateWindSpeed ( loc , windSpeed ) {
            // Set default highest speed of the meter
            let scaleMax = 20;

            if ( windSpeed > scaleMax ) {
                scaleMax = windSpeed;
            }
            jQuery("." + loc + "-windometer-legend-hi").html( scaleMax );

            // Convert speeds into angles
            let windSpeedometer = ( windSpeed / scaleMax * 180 ) - 90;

            // Keep the meter from over-shooting
            if ( windSpeedometer > 90 ) {
                windSpeedometer = 90;
            }

            jQuery("." + loc + "-wind-speed-arrow").css( "transform", "rotate(" + windSpeedometer + "deg)" );
        }

        // Display wind gusts if observed
        function windGusts ( loc , gustMPH , gustKTS ) {

            if ( !gustMPH ){
                jQuery("." + loc + "-wind-gust-mph").html( "" );
                jQuery("." + loc + "-wind-gust-kts").html( "" );
            } else {
                jQuery("." + loc + "-wind-gust-mph").html( "G" + gustMPH );
                jQuery("." + loc + "-wind-gust-kts").html( "G" + gustKTS );
            }
        }

        // Display and color code flight rules
        function flightRules ( loc , rules ) {

            jQuery("." + loc + "-rules").html( rules );
            if ( rules === "MVFR" ) {
                jQuery("." + loc + "-rules").css( "color", "rgb(102, 102, 255)" );
            } else if ( rules === "IFR" ) {
                jQuery("." + loc + "-rules").css( "color", "red" );
            } else if ( rules === "LIFR" ) {
                jQuery("." + loc + "-rules").css( "color", "purple" );
            } else if ( rules === "VFR" ) {
                jQuery("." + loc + "-rules").css( "color", "" );
            }
        }

        // Split up raw metar to display reported cloud layers
        function sky ( loc , raw ) {

            let rawSplit = raw.split(" ");
            let sky_html = "Sky:";
            
            for ( let j = 0; j < rawSplit.length; j++ ) {
                if ( rawSplit[j].slice(0,3) === "FEW" || rawSplit[j].slice(0,3) === "SCT"  || rawSplit[j].slice(0,3) === "BKN" || rawSplit[j].slice(0,3) === "OVC" ) {
                    sky_html += " " + rawSplit[j];
                } else if ( rawSplit[j] === "CLR" ) {
                    sky_html += " Clear";
                }
            }
            
            jQuery("." + loc + "-sky").html( sky_html );
        }

        // Station location identifier
        let location = data.observations[0].response[i].id;

        metarColorCode ( location , data.observations[0].response[i].ob.timestamp );
        rotateWindDir( location , data.observations[0].response[i].ob.windDirDEG );
        rotateWindSpeed ( location , data.observations[0].response[i].ob.windSpeedMPH );
        windGusts ( location , data.observations[0].response[i].ob.windGustMPH , data.observations[0].response[i].ob.windGustKTS );
        flightRules ( location, data.observations[0].response[i].ob.flightRule );
        sky ( location , data.observations[0].response[i].raw );

        jQuery("." + location + "-wind-direction").html( data.observations[0].response[i].ob.windDir );
        //jQuery("." + location + "-wind-direction-deg").html( data.observations[0].response[i].ob.windDirDEG + "&deg;" );
        jQuery("." + location + "-wind-speed-mph").html( data.observations[0].response[i].ob.windSpeedMPH );
        jQuery("." + location + "-wind-speed-kts").html( data.observations[0].response[i].ob.windSpeedKTS + " kts" );
        jQuery("." + location + "-vis").html("Vis:  " + data.observations[0].response[i].ob.visibilityMI + "sm" );

        if ( data.observations[0].response[i].ob.windDirDEG >= 0 ) {
            jQuery("." + location + "-wind-direction-deg").html( data.observations[0].response[i].ob.windDirDEG + "&deg;" );
        } else {
            jQuery("." + location + "-wind-direction-deg").html( "--" );
        }
    }

    //// Forecasts for Day Night Periods ////
    // Loop through each day-night forecast period and build forecast section HTML
    for (let i = 0; i < data.daynight[0].response[0].periods.length; i++) {

        if (data.daynight[0].response[0].periods[i].isDay) {
            if (i === 0) {
                jQuery(".forecast-p" + i + "-date").html("Today");
            } else {
                jQuery(".forecast-p" + i + "-date").html( dayjs.unix(data.daynight[0].response[0].periods[i].timestamp).format('dddd')  );
            }
            jQuery(".forecast-p" + i + "-hilo").html('High: <span class="forecast-p0-hilo forecast-hi">' + parseFloat(data.daynight[0].response[0].periods[i].maxTempF).toFixed(0) + '&deg;</span>');

        } else {
            if (i === 0 || i === 1) {
                jQuery(".forecast-p" + i + "-date").html("Tonight");
            } else {
                jQuery(".forecast-p" + i + "-date").html( dayjs.unix(data.daynight[0].response[0].periods[i].timestamp).format("ddd") + " Night"  );
            }
            jQuery(".forecast-p" + i + "-hilo").html('Low: <span class="forecast-p0-hilo forecast-lo">' + parseFloat(data.daynight[0].response[0].periods[i].minTempF).toFixed(0) + '&deg;</span>');
        }

        if (data.daynight[0].response[0].periods[i].windSpeedMinMPH === data.daynight[0].response[0].periods[i].windSpeedMaxMPH ){
            jQuery(".forecast-p" + i + "-windSpd").html(data.daynight[0].response[0].periods[i].windSpeedMPH + '');
        } else {
            jQuery(".forecast-p" + i + "-windSpd").html(data.daynight[0].response[0].periods[i].windSpeedMinMPH + ' - ' + data.daynight[0].response[0].periods[i].windSpeedMaxMPH + '');
        }

        jQuery(".forecast-p" + i + "-windDir").html(data.daynight[0].response[0].periods[i].windDir);
        jQuery(".forecast-p" + i + "-icon").html('<img src="./icons/' + data.daynight[0].response[0].periods[i].icon + '" align="right">');
        jQuery(".forecast-p" + i + "-wxPriCode").html( data.daynight[0].response[0].periods[i].weatherPrimary );
        jQuery(".forecast-p" + i + "-pop").html(data.daynight[0].response[0].periods[i].pop + '%');
        jQuery(".forecast-p" + i + "-precip").html(data.daynight[0].response[0].periods[i].precipIN + '"');
    }
}
